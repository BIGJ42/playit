<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Playit Music</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body {
      background: linear-gradient(135deg, #1e1e2f, #12121a);
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      color: white;
    }
    ::-webkit-scrollbar { width: 8px; }
    ::-webkit-scrollbar-thumb { background: #ffffff33; border-radius: 4px; }
    .modal-backdrop {
      background-color: rgba(0, 0, 0, 0.5);
      backdrop-filter: blur(5px);
    }

    /* Player Album Art */
    #albumArtImg {
        width: 5rem; /* w-20 */
        height: 5rem; /* h-20 */
        object-fit: cover;
        border-radius: 0.375rem; /* rounded-md */
        margin-right: 1rem; /* mr-4 */
        background-color: rgba(255, 255, 255, 0.05); /* bg-white/5 placeholder */
        background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 24 24' stroke-width='1.5' stroke='rgba(255,255,255,0.3)'%3E%3Cpath stroke-linecap='round' stroke-linejoin='round' d='M9 9l10.5-3m0 6.553v3.75a2.25 2.25 0 01-1.632 2.163l-1.32.377a1.803 1.803 0 11-.99-3.467l2.31-.66a2.25 2.25 0 001.632-2.163zm0 0V2.25L9 5.25v8.25a3.375 3.375 0 01-3.375 3.375H8.25a3.375 3.375 0 01-3.375-3.375V5.25L19.5 2.25v10.5a2.25 2.25 0 01-2.25 2.25h-1.5a2.25 2.25 0 01-2.25-2.25V9.75M15 12l3-3m0 0l-3-3m3 3H9M7.5 7.5H15m0 0V5.25M15 12V9.75m0 0A2.25 2.25 0 0012.75 7.5h-1.5A2.25 2.25 0 009 9.75v.75M7.5 15h3.75M7.5 18h3.75m0 0V11.25m0 0A2.25 2.25 0 0113.5 9h1.5a2.25 2.25 0 012.25 2.25m-3.75 0V15m0 0v3.75m0-3.75A2.25 2.25 0 0012.75 15h-1.5a2.25 2.25 0 00-2.25 2.25v.75M7.5 12h3.75' /%3E%3C/svg%3E");
        background-size: 40%;
        background-position: center;
        background-repeat: no-repeat;
        flex-shrink: 0;
        transition: background-image 0.3s ease;
    }
    #albumArtImg[src]:not([src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"]):not([src=""]) { /* When src is set to a real image and not empty/transparent pixel */
        background-image: none;
    }
    
    /* Expandable Playlist Styles */
    .playlist-item { /* Container for header + songs */
        background-color: rgba(255,255,255,0.07); /* bg-white/10 ish */
        border-radius: 0.375rem; /* rounded-md */
        transition: background-color 0.2s ease;
    }
    .playlist-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 0.6rem 0.75rem; /* py-2.5 px-3 */
        cursor: pointer;
        transition: background-color 0.2s ease;
    }
    .playlist-header:hover {
        background-color: rgba(255,255,255,0.1); /* Slightly lighter on hover */
    }
    .playlist-name {
        flex-grow: 1;
        font-size: 0.875rem; /* text-sm */
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
    }
    .playlist-arrow {
        margin-left: 0.5rem;
        transition: transform 0.3s ease-in-out;
        font-size: 0.7rem;
    }
    .playlist-item.expanded .playlist-arrow {
        transform: rotate(90deg);
    }
    .playlist-songs-container {
        max-height: 0;
        overflow-y: auto;
        transition: max-height 0.4s ease-in-out;
        background-color: rgba(255,255,255,0.03);
        border-bottom-left-radius: 0.375rem;
        border-bottom-right-radius: 0.375rem;
    }
    /* .playlist-songs-container.expanded is handled by JS setting max-height */
    .playlist-songs-container li {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 0.4rem 0.75rem 0.4rem 1.5rem; /* Indent song items */
        font-size: 0.8rem;
        cursor: pointer;
        border-top: 1px solid rgba(255,255,255,0.05);
    }
    .playlist-songs-container li:hover {
        background-color: rgba(255,255,255,0.08);
    }
    .playlist-song-name {
        flex-grow: 1;
        truncate: true; /* Ensure tailwind processes this if used elsewhere */
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
        padding-right: 0.5rem;
    }

  </style>
</head>
<body class="flex h-screen overflow-hidden">
  <!-- SONG LIST -->
  <div class="w-1/4 p-4 overflow-y-auto bg-white/10 backdrop-blur-md rounded-r-3xl shadow-md">
    <div class="mb-4">
      <button id="uploadBtn" class="w-full bg-purple-600 hover:bg-purple-700 text-white font-bold py-2 px-4 rounded transition">
        Upload Song to GitHub
      </button>
      <input type="file" id="fileInput" accept=".mp3" class="hidden">
      <p id="uploadStatus" class="text-xs mt-2 text-gray-300 h-4"></p>
    </div>
    <h2 class="text-xl font-bold mb-4">Songs</h2>
    <ul id="songList" class="space-y-2"></ul>
  </div>

  <!-- MAIN CONTENT -->
  <div class="flex-1 flex flex-col">
    <!-- PLAYER SECTION -->
    <div id="player" class="bg-white/10 backdrop-blur-md rounded-2xl p-4 m-4 w-full max-w-3xl self-center text-white shadow-lg">
      <div class="flex mb-3">
        <img id="albumArtImg" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="Album Art">
        <div class="flex-1 min-w-0"> <!-- min-w-0 helps with flex item truncation -->
          <div class="flex items-center justify-between mb-1">
            <div id="currentSongTitle" class="text-lg font-semibold truncate">No song playing</div>
            <div class="flex items-center space-x-3">
                <button id="addToPlaylistBtn" title="Add to Playlist" class="text-white text-xl hover:scale-110 transition">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M9 13h6m-3-3v6m-9 1V7a2 2 0 012-2h6l2 2h6a2 2 0 012 2v8a2 2 0 01-2 2H5a2 2 0 01-2-2z" />
                      </svg>
                </button>
                <div class="text-sm" id="timeDisplay">0:00 / 0:00</div>
            </div>
          </div>
          <input type="range" id="progressBar" value="0" min="0" max="100"
                 class="w-full appearance-none h-1 bg-white/30 rounded-lg cursor-pointer mb-2">
        </div>
      </div>
      <div class="flex items-center justify-center space-x-6 mb-3">
        <button id="prevBtn" class="text-white text-2xl hover:scale-110 transition">â—€â—€</button>
        <button id="playPauseBtn" class="text-white text-3xl hover:scale-110 transition">â–¶</button>
        <button id="nextBtn" class="text-white text-2xl hover:scale-110 transition">â–¶â–¶</button>
      </div>
      <div class="flex items-center space-x-2">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-white" viewBox="0 0 20 20" fill="currentColor">
          <path d="M9 4.804A1 1 0 0110.777 4l6.446 3.224a1 1 0 010 1.552l-6.446 3.224A1 1 0 019 11.196V4.804zM4 5a1 1 0 011 1v8a1 1 0 01-2 0V6a1 1 0 011-1z"/>
        </svg>
        <input type="range" id="volumeControl" min="0" max="1" step="0.01" value="1"
               class="w-full max-w-xs appearance-none h-1 bg-white/30 rounded cursor-pointer">
      </div>
    </div>

    <!-- PLAYLISTS SECTION -->
    <div class="flex-1 overflow-y-auto p-4 bg-white/5 backdrop-blur-md rounded-t-3xl">
        <div> <!-- Replaced allPlaylistsView, singlePlaylistView is removed -->
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-xl font-bold">Playlists</h2>
                <button id="showCreatePlaylistInputBtn" class="bg-purple-600 hover:bg-purple-700 text-white py-1 px-3 rounded text-sm">New Playlist</button>
            </div>
            <div id="createPlaylistInputContainer" class="hidden mb-3">
                <input type="text" id="newPlaylistNameInput" placeholder="New playlist name..." class="bg-white/20 text-white placeholder-gray-300 p-2 rounded w-full mb-2">
                <button id="confirmCreatePlaylistBtn" class="bg-green-500 hover:bg-green-600 text-white py-1 px-3 rounded text-sm mr-2">Create</button>
                <button id="cancelCreatePlaylistBtn" class="bg-red-500 hover:bg-red-600 text-white py-1 px-3 rounded text-sm">Cancel</button>
            </div>
            <ul id="playlistsList" class="space-y-2">
                <!-- Playlists will be rendered here -->
            </ul>
        </div>
    </div>
  </div>

  <!-- ADD TO PLAYLIST MODAL -->
  <div id="playlistModal" class="fixed inset-0 modal-backdrop flex items-center justify-center p-4 hidden z-50">
    <div class="bg-gray-800/80 backdrop-blur-lg p-6 rounded-lg shadow-xl w-full max-w-md text-white">
        <h3 class="text-lg font-semibold mb-4">Add to Playlist</h3>
        <p id="modalSongToAdd" class="text-sm mb-3 truncate"></p>
        <div class="mb-3">
            <label for="existingPlaylistsSelect" class="block text-sm font-medium mb-1">Select Existing Playlist:</label>
            <select id="existingPlaylistsSelect" class="w-full p-2 rounded bg-gray-700 border border-gray-600 focus:ring-purple-500 focus:border-purple-500">
                <!-- Options will be populated by JS -->
            </select>
            <button id="confirmAddToExistingPlaylistBtn" class="mt-2 w-full bg-blue-600 hover:bg-blue-700 text-white py-2 px-4 rounded transition">Add to Selected</button>
        </div>
        <div class="text-center my-2 text-gray-400">OR</div>
        <div>
            <label for="modalNewPlaylistNameInput" class="block text-sm font-medium mb-1">Create New Playlist:</label>
            <input type="text" id="modalNewPlaylistNameInput" placeholder="New playlist name" class="w-full p-2 rounded bg-gray-700 border border-gray-600 focus:ring-purple-500 focus:border-purple-500">
            <button id="confirmCreateAndAddToPlaylistBtn" class="mt-2 w-full bg-green-600 hover:bg-green-700 text-white py-2 px-4 rounded transition">Create & Add</button>
        </div>
        <button id="closePlaylistModalBtn" class="mt-4 w-full bg-gray-600 hover:bg-gray-500 text-white py-2 px-4 rounded transition">Cancel</button>
    </div>
  </div>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2867385638543028"
     crossorigin="anonymous"></script>
<!-- Playit ad 1 -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-2867385638543028"
     data-ad-slot="4319741119"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
  <script>
    const audio = new Audio();
    let currentSongIndex = -1;
    let songs = [];
    let playlists = [];
    let songToAdd_global = null;
    const TRANSPARENT_PIXEL = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7";


    // DOM Elements
    const playPauseBtn = document.getElementById("playPauseBtn");
    const progressBar = document.getElementById("progressBar");
    const volumeControl = document.getElementById("volumeControl");
    const currentSongTitle = document.getElementById("currentSongTitle");
    const timeDisplay = document.getElementById("timeDisplay");
    const songListUL = document.getElementById("songList");
    const albumArtImg = document.getElementById("albumArtImg");

    // GitHub Upload elements
    const uploadBtn = document.getElementById("uploadBtn");
    const fileInput = document.getElementById("fileInput");
    const uploadStatus = document.getElementById("uploadStatus");
    let GITHUB_TOKEN = "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"; // ðŸš¨ PASTE YOUR GITHUB PERSONAL ACCESS TOKEN HERE (Needed for UPLOADING)
    const GITHUB_OWNER = "bigj42";
    const GITHUB_REPO = "playit";
    const GITHUB_PATH = "drive.google.com/music"; // This is the folder path within your repository
    const GITHUB_BRANCH = "main";

    // Playlist UI Elements
    const addToPlaylistBtn = document.getElementById("addToPlaylistBtn");
    const playlistModal = document.getElementById("playlistModal");
    const modalSongToAdd = document.getElementById("modalSongToAdd");
    const existingPlaylistsSelect = document.getElementById("existingPlaylistsSelect");
    const confirmAddToExistingPlaylistBtn = document.getElementById("confirmAddToExistingPlaylistBtn");
    const modalNewPlaylistNameInput = document.getElementById("modalNewPlaylistNameInput");
    const confirmCreateAndAddToPlaylistBtn = document.getElementById("confirmCreateAndAddToPlaylistBtn");
    const closePlaylistModalBtn = document.getElementById("closePlaylistModalBtn");

    const playlistsListUL = document.getElementById("playlistsList");
    const showCreatePlaylistInputBtn = document.getElementById("showCreatePlaylistInputBtn");
    const createPlaylistInputContainer = document.getElementById("createPlaylistInputContainer");
    const newPlaylistNameInput = document.getElementById("newPlaylistNameInput");
    const confirmCreatePlaylistBtn = document.getElementById("confirmCreatePlaylistBtn");
    const cancelCreatePlaylistBtn = document.getElementById("cancelCreatePlaylistBtn");
    

    // --- DATA MANAGEMENT ---
    function loadPlaylistsFromStorage() {
        const storedPlaylists = localStorage.getItem('musicPlayerPlaylists');
        playlists = storedPlaylists ? JSON.parse(storedPlaylists) : [];
    }

    function savePlaylistsToStorage() {
        localStorage.setItem('musicPlayerPlaylists', JSON.stringify(playlists));
    }

    // --- GITHUB SONG LOADING ---
    function loadSongsFromGitHub() {
      const cacheBuster = new Date().getTime();
      
      // Check token for UPLOAD capabilities, not for loading songs from a public repo.
      if (!GITHUB_TOKEN) {
          uploadStatus.textContent = "GitHub token not set. Uploads disabled.";
          // You could visually disable the upload button here too if desired:
          // uploadBtn.disabled = true;
          // uploadBtn.classList.add('opacity-50', 'cursor-not-allowed');
          console.warn("GitHub token not set. Song uploads will be disabled.");
      } else {
          uploadStatus.textContent = ""; // Clear any previous token-related messages if token is present
          // uploadBtn.disabled = false;
          // uploadBtn.classList.remove('opacity-50', 'cursor-not-allowed');
      }

      songListUL.innerHTML = '<li>Loading songs from GitHub...</li>'; // Initial loading message

      // Fetching from a public repository's contents API does not require a token.
      fetch(`https://api.github.com/repos/${GITHUB_OWNER}/${GITHUB_REPO}/contents/${GITHUB_PATH}?t=${cacheBuster}`)
        .then(res => {
            if (!res.ok) {
                let errorMsg = `GitHub API Error: ${res.status} ${res.statusText}.`;
                if (res.status === 403) { // Forbidden
                    errorMsg += " This could be due to API rate limits (try again later) or the repository/path not being public.";
                } else if (res.status === 404) { // Not Found
                    errorMsg += " Ensure the repository is public and the path is correct.";
                }
                throw new Error(errorMsg);
            }
            return res.json();
        })
        .then(data => {
          if (Array.isArray(data)) {
            songs = data.filter(file => file.name.endsWith(".mp3") && file.type === "file")
                        .map(file => {
                            return { 
                                name: file.name, 
                                url: file.download_url, // download_url from public repo contents API is publicly accessible
                                id: file.sha,
                                albumArtUrl: null // Album art logic remains separate
                            };
                        }); 
            if (songs.length === 0) {
                songListUL.innerHTML = `<li>No MP3 files found in: <br><small class="break-all">${GITHUB_OWNER}/${GITHUB_REPO}/${GITHUB_PATH}</small></li>`;
            } else {
                renderSongList(); // This will clear and re-populate songListUL
            }
          } else if (data && data.message) { // Handle GitHub API error object e.g. { message: "Not Found", ... }
            console.error("Failed to load songs, GitHub API error:", data.message);
            songListUL.innerHTML = `<li>Error loading songs: ${data.message}</li>`;
            if (data.message.toLowerCase().includes("not found")) {
                 songListUL.innerHTML += ` (Check repo/path: ${GITHUB_OWNER}/${GITHUB_REPO}/${GITHUB_PATH})`;
            }
          } else {
            console.error("Failed to load songs, response was not an array or a known error format:", data);
            songListUL.innerHTML = `<li>Error: Could not parse song data from GitHub.</li>`;
          }
        })
        .catch(error => {
            console.error("Error fetching songs from GitHub:", error);
            songListUL.innerHTML = `<li>Error fetching songs: ${error.message}</li>`;
        });
    }

    function renderSongList() {
      songListUL.innerHTML = ""; // Clear previous list or loading/error messages

      // If songs array is empty at this point, loadSongsFromGitHub should have already set an appropriate message.
      // This is a fallback or if something else cleared songListUL.
      if (songs.length === 0) {
          if (songListUL.innerHTML.trim() === "") { // Only add if no error message is already there
            songListUL.innerHTML = `<li>No songs to display.</li>`;
          }
          return;
      }

      songs.forEach((song, index) => {
        const li = document.createElement("li");
        li.className = "p-2 bg-white/10 rounded hover:bg-white/20 cursor-pointer text-sm truncate";
        li.textContent = song.name;
        li.onclick = () => playSongFromMainList(index);
        songListUL.appendChild(li);
      });
    }

    // --- PLAYER LOGIC ---
    function playSong(songObject) { 
        if (!songObject || !songObject.url) {
            console.error("Invalid song object for playback:", songObject);
            currentSongTitle.textContent = "Error: Invalid song";
            albumArtImg.src = TRANSPARENT_PIXEL; 
            return;
        }
        audio.src = songObject.url;
        currentSongTitle.textContent = songObject.name;
        
        if (songObject.albumArtUrl) {
            albumArtImg.src = songObject.albumArtUrl;
        } else {
            albumArtImg.src = TRANSPARENT_PIXEL; 
        }

        audio.play();
        playPauseBtn.innerHTML = "âšâš";
        
        const mainListIndex = songs.findIndex(s => (s.id && s.id === songObject.id) || s.url === songObject.url);
        currentSongIndex = mainListIndex !== -1 ? mainListIndex : -1; // if from playlist, might not be in main `songs` by index
        
        addToPlaylistBtn.disabled = false; 
    }
    
    function playSongFromMainList(index) {
        if (songs.length === 0 || index < 0 || index >= songs.length) return;
        currentSongIndex = index; // Ensure currentSongIndex is set for main list playback
        playSong(songs[currentSongIndex]);
    }

    playPauseBtn.onclick = () => {
      if (!audio.src) { 
        if (songs.length > 0) playSongFromMainList(0);
        return;
      }
      if (audio.paused) {
        audio.play();
        playPauseBtn.innerHTML = "âšâš";
      } else {
        audio.pause();
        playPauseBtn.innerHTML = "â–¶";
      }
    };

    document.getElementById("prevBtn").onclick = () => {
      if (songs.length === 0) return;
      if (currentSongIndex === -1 && songs.length > 0) { // If playing from playlist, try to find in main list or play first
          const currentPlayingSong = songs.find(s => s.url === audio.src);
          if (currentPlayingSong) {
              currentSongIndex = songs.indexOf(currentPlayingSong);
          } else {
              currentSongIndex = 0; // Fallback to first song
          }
      }
      currentSongIndex = (currentSongIndex - 1 + songs.length) % songs.length;
      playSongFromMainList(currentSongIndex);
    };

    document.getElementById("nextBtn").onclick = () => {
      if (songs.length === 0) return;
      if (currentSongIndex === -1 && songs.length > 0) { // If playing from playlist, try to find in main list or play first
          const currentPlayingSong = songs.find(s => s.url === audio.src);
          if (currentPlayingSong) {
              currentSongIndex = songs.indexOf(currentPlayingSong);
          } else {
              currentSongIndex = -1; // will become 0 after +1
          }
      }
      currentSongIndex = (currentSongIndex + 1) % songs.length;
      playSongFromMainList(currentSongIndex);
    };
    
    audio.addEventListener("ended", () => document.getElementById("nextBtn").click());

    progressBar.addEventListener("input", () => { if (audio.duration && !isNaN(audio.duration)) audio.currentTime = (progressBar.value / 100) * audio.duration; });
    volumeControl.addEventListener("input", () => { audio.volume = volumeControl.value; });
    audio.addEventListener("timeupdate", () => {
      if (!isNaN(audio.duration) && audio.duration > 0) {
        progressBar.value = (audio.currentTime / audio.duration) * 100;
        const formatTime = (t) => `${Math.floor(t / 60)}:${String(Math.floor(t % 60)).padStart(2, "0")}`;
        timeDisplay.textContent = `${formatTime(audio.currentTime)} / ${formatTime(audio.duration)}`;
      } else {
        progressBar.value = 0;
        timeDisplay.textContent = "0:00 / 0:00";
      }
    });

    // --- PLAYLIST MODAL LOGIC ---
    addToPlaylistBtn.onclick = () => {
        let songToAdd;
        // Prioritize currently indexed song from main list if valid
        if (currentSongIndex !== -1 && songs[currentSongIndex] && songs[currentSongIndex].url === audio.src) {
            songToAdd = songs[currentSongIndex];
        } 
        // If not from main list (e.g. playlist song) or index is out of sync, reconstruct from player
        else if (audio.src && currentSongTitle.textContent !== "No song playing" && currentSongTitle.textContent !== "Error: Invalid song") {
             songToAdd = { 
                name: currentSongTitle.textContent, 
                url: audio.src, 
                // Try to find ID from main songs list, otherwise use URL as ID
                id: songs.find(s => s.url === audio.src)?.id || audio.src, 
                albumArtUrl: albumArtImg.src === TRANSPARENT_PIXEL ? null : albumArtImg.src 
            }; 
        } else {
            alert("Cannot determine the current song to add.");
            return;
        }
        
        songToAdd_global = { ...songToAdd }; 

        modalSongToAdd.textContent = `Song: ${songToAdd_global.name}`;
        populateExistingPlaylistsSelect();
        playlistModal.classList.remove('hidden');
    };

    closePlaylistModalBtn.onclick = () => {
        playlistModal.classList.add('hidden');
        modalNewPlaylistNameInput.value = ''; 
        songToAdd_global = null;
    };

    function populateExistingPlaylistsSelect() {
        existingPlaylistsSelect.innerHTML = '<option value="">-- Select a Playlist --</option>';
        if (playlists.length === 0) {
            existingPlaylistsSelect.innerHTML = '<option value="" disabled>No playlists yet. Create one below.</option>';
            return;
        }
        playlists.forEach(pl => {
            const option = document.createElement('option');
            option.value = pl.id;
            option.textContent = pl.name;
            existingPlaylistsSelect.appendChild(option);
        });
    }

    confirmAddToExistingPlaylistBtn.onclick = () => {
        const playlistId = existingPlaylistsSelect.value;
        if (!playlistId) { alert("Please select a playlist."); return; }
        if (!songToAdd_global) { alert("Error: No song selected to add."); return; }
        addSongToPlaylist(playlistId, songToAdd_global);
        closePlaylistModalBtn.click(); 
    };

    confirmCreateAndAddToPlaylistBtn.onclick = () => {
        const newName = modalNewPlaylistNameInput.value.trim();
        if (!newName) { alert("Please enter a name for the new playlist."); return; }
        if (!songToAdd_global) { alert("Error: No song selected to add."); return; }
        const newPlaylist = createPlaylist(newName);
        if (newPlaylist) {
            addSongToPlaylist(newPlaylist.id, songToAdd_global);
        }
        closePlaylistModalBtn.click(); 
    };

    // --- PLAYLIST MANAGEMENT LOGIC ---
    function generatePlaylistId() { return 'pl-' + Date.now().toString() + Math.random().toString(36).substring(2, 7); }


    function createPlaylist(name) {
        if (!name.trim()) return null;
        const newPlaylist = { id: generatePlaylistId(), name: name.trim(), songs: [] };
        playlists.push(newPlaylist);
        savePlaylistsToStorage();
        renderPlaylistsList();
        return newPlaylist;
    }

    function addSongToPlaylist(playlistId, songObject) {
        const playlist = playlists.find(p => p.id === playlistId);
        if (playlist) {
            const songExists = playlist.songs.some(s => 
                (s.id && songObject.id && s.id === songObject.id) || // Compare by ID if both exist
                s.url === songObject.url // Fallback to URL comparison
            );

            if (!songExists) {
                playlist.songs.push({ 
                    name: songObject.name, 
                    url: songObject.url, 
                    id: songObject.id || songObject.url, // Ensure ID is present
                    albumArtUrl: songObject.albumArtUrl || null 
                }); 
                savePlaylistsToStorage();
                alert(`'${songObject.name}' added to '${playlist.name}'.`);
                renderPlaylistsList(); 
            } else {
                alert(`'${songObject.name}' is already in '${playlist.name}'.`);
            }
        }
    }
    
    function removeSongFromPlaylist(playlistId, songIdOrUrl) {
        const playlist = playlists.find(p => p.id === playlistId);
        if (playlist) {
            const originalLength = playlist.songs.length;
            playlist.songs = playlist.songs.filter(s => {
                // Check ID first if both song.id and songIdOrUrl could be actual SHAs
                if (s.id && typeof songIdOrUrl === 'string' && !songIdOrUrl.startsWith('http')) {
                    return s.id !== songIdOrUrl;
                }
                // Fallback to URL or if songIdOrUrl is clearly a URL
                return s.url !== songIdOrUrl;
            });

            if (playlist.songs.length < originalLength) {
                savePlaylistsToStorage();
                const playlistItemDiv = document.getElementById(`playlist-item-${playlistId}`);
                if (playlistItemDiv && playlistItemDiv.classList.contains('expanded')) {
                    const songsContainer = playlistItemDiv.querySelector('.playlist-songs-container');
                    renderSongsForPlaylistInPlace(playlist, songsContainer);
                    songsContainer.style.maxHeight = songsContainer.scrollHeight + 'px';
                }
                renderPlaylistsList(); // Update counts in the main list
            }
        }
    }

    function deletePlaylist(playlistId) {
        const playlistToDelete = playlists.find(p=>p.id===playlistId);
        if (!playlistToDelete) return;
        if (!confirm(`Are you sure you want to delete playlist '${playlistToDelete.name}'? This cannot be undone.`)) return;
        
        playlists = playlists.filter(p => p.id !== playlistId);
        savePlaylistsToStorage();
        renderPlaylistsList();
    }

    // --- RENDERING PLAYLISTS UI (EXPANDABLE) ---
    function renderPlaylistsList() {
        const oldExpandedStates = {}; 
        document.querySelectorAll('.playlist-item.expanded').forEach(item => {
            oldExpandedStates[item.id.replace('playlist-item-', '')] = true;
        });

        playlistsListUL.innerHTML = "";
        if (playlists.length === 0) {
            playlistsListUL.innerHTML = `<li class="text-gray-400 text-sm">No playlists created yet.</li>`;
            return;
        }

        playlists.forEach(pl => {
            const listItem = document.createElement('li');
            listItem.className = 'playlist-item';
            listItem.id = `playlist-item-${pl.id}`;

            const headerDiv = document.createElement('div');
            headerDiv.className = 'playlist-header';
            
            const nameSpan = document.createElement('span');
            nameSpan.className = 'playlist-name';
            nameSpan.textContent = `${pl.name} (${pl.songs.length} song${pl.songs.length === 1 ? '' : 's'})`;
            
            const controlsDiv = document.createElement('div');
            controlsDiv.className = 'flex items-center';

            const arrowSpan = document.createElement('span');
            arrowSpan.className = 'playlist-arrow mr-2';
            arrowSpan.innerHTML = 'â–¶'; 

            const deleteBtn = document.createElement('button');
            deleteBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 text-red-400 hover:text-red-300" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v6a1 1 0 102 0V8a1 1 0 00-1-1z" clip-rule="evenodd" /></svg>`;
            deleteBtn.title = "Delete Playlist";
            deleteBtn.className = "p-1"; 
            deleteBtn.onclick = (e) => { e.stopPropagation(); deletePlaylist(pl.id); };

            controlsDiv.appendChild(arrowSpan);
            controlsDiv.appendChild(deleteBtn);
            
            headerDiv.appendChild(nameSpan);
            headerDiv.appendChild(controlsDiv);

            const songsContainer = document.createElement('ul');
            songsContainer.className = 'playlist-songs-container';

            headerDiv.onclick = () => togglePlaylistExpansion(listItem, pl, songsContainer);
            
            listItem.appendChild(headerDiv);
            listItem.appendChild(songsContainer);
            playlistsListUL.appendChild(listItem);

            if (oldExpandedStates[pl.id]) {
                listItem.classList.add('expanded');
                renderSongsForPlaylistInPlace(pl, songsContainer);
                songsContainer.style.maxHeight = songsContainer.scrollHeight + 'px';
            }
        });
    }

    function togglePlaylistExpansion(playlistItemElement, playlistObject, songsContainerElement) {
        const isExpanded = playlistItemElement.classList.toggle('expanded');
        if (isExpanded) {
            renderSongsForPlaylistInPlace(playlistObject, songsContainerElement);
            songsContainerElement.style.maxHeight = songsContainerElement.scrollHeight + 'px';
        } else {
            songsContainerElement.style.maxHeight = '0px';
        }
    }

    function renderSongsForPlaylistInPlace(playlistObject, songsContainerElement) {
        songsContainerElement.innerHTML = ""; 
        if (playlistObject.songs.length === 0) {
            const li = document.createElement('li');
            li.className = "text-gray-400 text-xs italic px-6 py-2";
            li.textContent = "This playlist is empty.";
            songsContainerElement.appendChild(li);
        } else {
            playlistObject.songs.forEach((song) => { // Removed index as it's not used for playback here
                const li = document.createElement('li');
                
                const songNameSpan = document.createElement('span');
                songNameSpan.className = "playlist-song-name";
                songNameSpan.textContent = song.name;
                songNameSpan.onclick = (e) => { 
                    e.stopPropagation(); 
                    playSong(song); // Play the specific song object from the playlist
                };
                
                const removeSongBtn = document.createElement('button');
                removeSongBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" class="h-3.5 w-3.5 text-red-400 hover:text-red-300" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd" /></svg>`;
                removeSongBtn.title = "Remove from playlist";
                removeSongBtn.className = "p-1"; 
                removeSongBtn.onclick = (e) => { 
                    e.stopPropagation(); 
                    removeSongFromPlaylist(playlistObject.id, song.id || song.url); 
                };

                li.appendChild(songNameSpan);
                li.appendChild(removeSongBtn);
                songsContainerElement.appendChild(li);
            });
        }
    }

    showCreatePlaylistInputBtn.onclick = () => {
        createPlaylistInputContainer.classList.remove('hidden');
        showCreatePlaylistInputBtn.classList.add('hidden');
        newPlaylistNameInput.focus();
    };
    cancelCreatePlaylistBtn.onclick = () => {
        createPlaylistInputContainer.classList.add('hidden');
        showCreatePlaylistInputBtn.classList.remove('hidden');
        newPlaylistNameInput.value = '';
    };
    confirmCreatePlaylistBtn.onclick = () => {
        const name = newPlaylistNameInput.value.trim();
        if (name) {
            createPlaylist(name);
            newPlaylistNameInput.value = '';
            createPlaylistInputContainer.classList.add('hidden');
            showCreatePlaylistInputBtn.classList.remove('hidden');
        } else {
            alert("Playlist name cannot be empty.");
        }
    };

    // --- GITHUB UPLOAD LOGIC ---
    uploadBtn.onclick = () => {
      if (!GITHUB_TOKEN) {
          uploadStatus.textContent = "GitHub token not configured. Cannot upload.";
          // Optionally, you could also `alert("GitHub token not configured. Cannot upload.");`
          return;
      }
      fileInput.click();
    };

    fileInput.onchange = async (event) => {
      const file = event.target.files[0];
      if (file) {
        if (!file.name.endsWith(".mp3")) {
            uploadStatus.textContent = "Please select an .mp3 file.";
            fileInput.value = ""; return;
        }
        await uploadFileToGitHub(file);
        fileInput.value = ""; // Reset file input
      }
    };

    async function uploadFileToGitHub(file) { 
        if (!GITHUB_TOKEN) { // Double check, though uploadBtn.onclick should prevent this
          uploadStatus.textContent = "GitHub Token not set! Cannot upload."; return;
        }
        uploadStatus.textContent = `Uploading ${file.name}...`;
        const reader = new FileReader();
        reader.onload = async (e) => {
            const content = e.target.result.split(',')[1]; // Base64 content
            const filePath = `${GITHUB_PATH}/${file.name}`; // Ensure GITHUB_PATH doesn't have leading/trailing slashes if file.name does
            const url = `https://api.github.com/repos/${GITHUB_OWNER}/${GITHUB_REPO}/contents/${filePath}`;
            
            let sha = null;
            try { // Check if file exists to get SHA (for updates)
                const existingFileRes = await fetch(url, { headers: { 'Authorization': `token ${GITHUB_TOKEN}` }});
                if (existingFileRes.ok) {
                    const existingFile = await existingFileRes.json();
                    sha = existingFile.sha;
                } else if (existingFileRes.status !== 404) { // Don't error for 404 (file not found)
                    console.warn(`Could not fetch existing file info (status ${existingFileRes.status}), proceeding without SHA.`);
                }
            } catch (err) { 
                console.warn("Error checking for existing file (might be network issue):", err);
            }

            const body = { 
                message: `feat: ${sha ? 'update' : 'add'} song '${file.name}'`, 
                content: content, 
                branch: GITHUB_BRANCH,
                ...(sha && { sha: sha }) // Add SHA only if we have one (for updating existing file)
            };

            try {
                const response = await fetch(url, {
                    method: 'PUT',
                    headers: { 
                        'Authorization': `token ${GITHUB_TOKEN}`, 
                        'Accept': 'application/vnd.github.v3+json',
                        'Content-Type': 'application/json' // Important for JSON body
                    },
                    body: JSON.stringify(body),
                });
                const result = await response.json();
                if (response.ok) {
                    uploadStatus.textContent = `${file.name} ${sha ? 'updated' : 'uploaded'}! Refreshing...`;
                    setTimeout(() => { 
                        loadSongsFromGitHub(); // Refresh song list
                        uploadStatus.textContent = ""; 
                    }, 2000);
                } else {
                    uploadStatus.textContent = `Error: ${result.message || response.statusText}`;
                    if (response.status === 401) uploadStatus.textContent += " (Token invalid/expired or no repo write access?)";
                    if (response.status === 409) uploadStatus.textContent += " (Conflict - try again or refresh song list if SHA mismatch)";
                    if (response.status === 422 && result.message && result.message.includes("sha")) uploadStatus.textContent += " (File changed on server. Refresh list & re-upload)";
                    console.error("GitHub Upload Error:", result);
                }
            } catch (error) { 
                uploadStatus.textContent = `Network error during upload: ${error.message}`; 
                console.error("Network error during upload:", error);
            }
        };
        reader.onerror = (error) => {
            uploadStatus.textContent = 'Error reading file.';
            console.error('FileReader error:', error);
        };
        reader.readAsDataURL(file);
    }

    // --- INITIALIZATION ---
    function initializeApp() {
        albumArtImg.src = TRANSPARENT_PIXEL; 
        loadSongsFromGitHub(); // Will attempt to load songs (token not needed for this step if repo public)
        loadPlaylistsFromStorage();
        renderPlaylistsList();
        addToPlaylistBtn.disabled = true; // Disabled until a song is playing
    }

    initializeApp();

  </script>
</body>
</html>
